/**
 * API Optimizer and Duplicate Message Preventer
 *
 * This self-contained script solves two major issues:
 * 1. Optimizes API calls by deduplicating and caching requests
 * 2. Prevents duplicate messages when contacting sellers
 *
 * INSTALLATION:
 * 1. Open your browser's developer console (F12 or Command+Option+I)
 * 2. Copy and paste this entire script into the console
 * 3. Press Enter to run the script
 *
 * The script will automatically:
 * - Intercept and optimize API calls
 * - Prevent duplicate "Contact Seller" redirects
 * - Keep track of conversation states
 * - Clean up existing duplicate messages
 */

(function () {
  console.log("🚀 API Optimizer & Duplicate Message Preventer: Starting...");

  // ===== REQUEST OPTIMIZATION =====

  // Storage for active and completed requests
  const activeRequests = new Map();
  const completedRequests = new Map();
  const CACHE_EXPIRATION_MS = 5000; // 5 seconds cache

  // Store the original fetch method
  const originalFetch = window.fetch;

  // Override fetch to optimize requests
  window.fetch = function optimizedFetch(resource, options) {
    // Generate unique request key
    const requestKey = generateRequestKey(resource, options);
    const endpointName = extractEndpointName(resource);

    // Skip optimization for specific non-supabase endpoints or non-GET requests
    if (
      !resource.toString().includes("supabase") ||
      (options && options.method && options.method !== "GET")
    ) {
      return originalFetch(resource, options);
    }

    // Check if there's an active request for the same endpoint
    if (activeRequests.has(requestKey)) {
      console.log(`🔄 Reusing active request for: ${endpointName}`);
      return activeRequests.get(requestKey);
    }

    // Check if there's a cached response that's still valid
    if (completedRequests.has(requestKey)) {
      const cachedData = completedRequests.get(requestKey);
      const isCacheValid =
        Date.now() - cachedData.timestamp < CACHE_EXPIRATION_MS;

      if (isCacheValid) {
        console.log(`📦 Using cached response for: ${endpointName}`);
        return Promise.resolve(
          new Response(JSON.stringify(cachedData.data), {
            headers: { "Content-Type": "application/json" },
          })
        );
      } else {
        // Remove expired cache
        completedRequests.delete(requestKey);
      }
    }

    // Execute the request and store it
    const requestPromise = originalFetch(resource, options)
      .then(async (response) => {
        // Clone the response so we can use it and also cache it
        const clone = response.clone();

        // Store in completed requests cache
        try {
          const responseData = await clone.json();
          completedRequests.set(requestKey, {
            data: responseData,
            timestamp: Date.now(),
          });
        } catch (e) {
          // If we can't parse JSON, just continue
        }

        // Remove from active requests
        activeRequests.delete(requestKey);

        return response;
      })
      .catch((error) => {
        // Remove from active requests on error
        activeRequests.delete(requestKey);
        throw error;
      });

    // Store the promise in active requests
    activeRequests.set(requestKey, requestPromise);
    console.log(`📤 Optimized request: ${endpointName}`);

    return requestPromise;
  };

  // Clean up expired cache periodically
  setInterval(() => {
    const now = Date.now();
    for (const [key, cachedData] of completedRequests.entries()) {
      if (now - cachedData.timestamp > CACHE_EXPIRATION_MS) {
        completedRequests.delete(key);
      }
    }
  }, 30000); // Check every 30 seconds

  // Helper function to generate a unique key for a request
  function generateRequestKey(resource, options) {
    const resourceStr = resource.toString();
    const optionsStr = options ? JSON.stringify(options) : "";
    return `${resourceStr}:${optionsStr}`;
  }

  // Helper function to extract endpoint name for logging
  function extractEndpointName(resource) {
    const url = resource.toString();
    const parts = url.split("/");
    return parts[parts.length - 1].split("?")[0];
  }

  // ===== DUPLICATE MESSAGE PREVENTION =====

  // Store for conversations that have been initiated
  const initiatedConversations = new Set();

  // Try to load previously initiated conversations from localStorage
  try {
    const saved = localStorage.getItem("initiatedConversations");
    if (saved) {
      const parsed = JSON.parse(saved);
      if (Array.isArray(parsed)) {
        parsed.forEach((item) => initiatedConversations.add(item));
      }
    }
  } catch (e) {
    console.error("Error loading initiated conversations", e);
  }

  // Create keys for managing conversations
  const createConversationKey = (sellerId, productId) =>
    `${sellerId}:${productId}`;

  // Override window.location to prevent duplicate redirects
  const originalLocationDescriptor = Object.getOwnPropertyDescriptor(
    window,
    "location"
  );

  Object.defineProperty(window, "location", {
    get: function () {
      return originalLocationDescriptor.get.call(this);
    },
    set: function (val) {
      try {
        const url = new URL(val, window.location.origin);

        // Check if this is a messaging-related redirect
        if (
          url.pathname.includes("/messages/") &&
          url.search.includes("productId=")
        ) {
          // Extract seller and product IDs from URL
          const sellerId = url.pathname.split("/messages/")[1];
          const params = new URLSearchParams(url.search);
          const productId = params.get("productId");

          if (sellerId && productId) {
            const conversationKey = createConversationKey(sellerId, productId);

            // Check if this conversation has already been initiated
            if (initiatedConversations.has(conversationKey)) {
              console.log(
                `🛑 Blocked duplicate redirect to conversation: ${conversationKey}`
              );
              return; // Prevent the redirect
            }

            // Mark this conversation as initiated
            initiatedConversations.add(conversationKey);

            // Save to localStorage for persistence
            try {
              localStorage.setItem(
                "initiatedConversations",
                JSON.stringify(Array.from(initiatedConversations))
              );
            } catch (e) {
              console.error("Error saving initiated conversations", e);
            }

            console.log(
              `✅ Allowing redirect to new conversation: ${conversationKey}`
            );
          }
        }
      } catch (e) {
        console.error("Error in location override", e);
      }

      // Proceed with the redirect
      originalLocationDescriptor.set.call(this, val);
    },
    configurable: true,
  });

  // ===== DUPLICATE MESSAGE CLEANUP =====

  async function cleanupDuplicateMessages() {
    try {
      console.log("🧹 Starting cleanup of duplicate messages...");

      // Get current user
      const {
        data: { user },
      } = await supabase.auth.getUser();
      if (!user) {
        console.log("❌ No authenticated user found. Please login first.");
        return;
      }

      const currentUserId = user.id;
      console.log(`👤 Found current user: ${currentUserId}`);

      // Get all messages sent by the current user
      const { data: messages, error } = await supabase
        .from("messages")
        .select("*")
        .eq("sender_id", currentUserId)
        .order("created_at", { ascending: true });

      if (error) {
        console.error("Error fetching messages:", error);
        return;
      }

      console.log(`📨 Found ${messages.length} messages sent by you`);

      // Group messages by conversation and content
      const messageGroups = {};

      messages.forEach((message) => {
        // Create a key that groups by receiver, product, and message content
        const groupKey = `${message.receiver_id}:${
          message.product_id || "no-product"
        }:${message.content}`;

        if (!messageGroups[groupKey]) {
          messageGroups[groupKey] = [];
        }

        messageGroups[groupKey].push(message);
      });

      // Find and delete duplicates (keeping the oldest message in each group)
      let deletedCount = 0;
      let processedGroups = 0;

      for (const groupKey in messageGroups) {
        const group = messageGroups[groupKey];
        processedGroups++;

        // If there are duplicates
        if (group.length > 1) {
          // Sort by created_at (ascending)
          group.sort((a, b) => new Date(a.created_at) - new Date(b.created_at));

          // Keep the oldest message, delete the rest
          const toDelete = group.slice(1);

          for (const message of toDelete) {
            const { error } = await supabase
              .from("messages")
              .delete()
              .eq("id", message.id);

            if (error) {
              console.error(`Error deleting message ${message.id}:`, error);
            } else {
              deletedCount++;
            }
          }
        }

        // Progress update for larger sets
        if (processedGroups % 10 === 0) {
          console.log(
            `Progress: ${processedGroups}/${
              Object.keys(messageGroups).length
            } groups processed`
          );
        }
      }

      console.log(
        `✅ Cleanup complete! Deleted ${deletedCount} duplicate messages.`
      );
      return { processed: processedGroups, deleted: deletedCount };
    } catch (error) {
      console.error("Cleanup failed:", error);
      return { error: error.message };
    }
  }

  // Add cleanupDuplicateMessages function to window for easy access
  window.cleanupDuplicateMessages = cleanupDuplicateMessages;

  console.log(
    "✅ API Optimizer & Duplicate Message Preventer: Successfully installed!"
  );
  console.log(
    "ℹ️ To clean up existing duplicate messages, run: window.cleanupDuplicateMessages()"
  );
})();
